
#разбираюсь в связанных списках
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

    def append(self,val):
        end = Node(val)#cоздаем новый узел с заданным значением. Назовем его end
        n = self#оздаем указатель (поинтер, ссылку на головной элемент (head) нашего списка
        while (n.next):#проходим список,если следующего узла нет, мы поймем, что мы уже в конце списка.
            n = n.next
        n.next = end#указываем на последний узел, за которым нет следующего узла
#проверим. Начнем с создания нового объекта Node.
# Назовем его ll (две латинские буквы «l» в нижнем регистре как сокращение Linked List). Назначим ему значение 1.
ll = Node(1)
#метод append(),вызывать его для добавления в наш список новых узлов.

ll.append(2)
ll.append(3)

# Как нам увидеть, как выглядит наш список? Теоретически, выглядеть он должен следующим образом:
#
#   [1] --> [2] --> [3]
# Но нет способа вывести его именно в таком виде. Нам нужно пройти список, выводя каждое значение.
# Вы же помните, как проходить список? Мы только что это делали. Повторим:
#
# Создаем переменную, указывающую на head.
# Если есть следующий узел, перемещаемся к этому узлу.
# И просто выводим data в каждом узле. Мы начинаем с шага № 1: создаем новую переменную и назначаем ее головным элементом списка.
#
#  node = ll
# Далее мы выводим первый узел. Почему мы не начали с цикла while?
# Цикл while проитерируется только дважды, потому что только у двух узлов есть next (у последнего узла его нет).
# В информатике это называется ошибкой на единицу (когда нужно сделать что-то Х раз плюс 1). Это можно представить в виде забора.
# Вы ставите столб, затем секцию забора, и чередуете пару столб + секция столько раз, сколько нужно по длине.
# Но вы не можете оставить последнюю секцию забора висящей в воздухе. Ограда должна закончиться столбом, а не секцией.
# Поэтому вам приходится либо добавлять еще один столб в конце, либо (что в информатике более распространено) начать с постановки столба,
# а затем добавлять пары секция + столб. Это мы и сделаем.
#
# Для начала мы выведем первый узел, а затем запустим цикл while для вывода всех последующих узлов.
node = ll
print(node.data)
while node.next:
    node = node.next
    print(node.data)

# Зачем уметь создавать связный список на Python?
# Зачем вообще может понадобиться создавать собственный связный список на Python? Это хороший вопрос.
# Использование связных списков имеет некоторые преимущества по сравнению с использованием просто списков Python.
#
# Традиционно вопрос звучит как «чем использование связного списка лучше использования массива».
# Основная идея в том, что массивы в Java и других ООП-языках имеют фиксированный размер,
# поэтому для добавления элемента приходится создавать новый массив с размером N + 1 и помещать в него все значения из предыдущего массива.
# Пространственная и временная сложность этой операции — O(N). А вот добавление элемента в конец связного списка имеет постоянную временную сложность (O(1)).
#
# Списки в Python это не настоящие массивы, а скорее реализация динамического массива, что имеет свои преимущества и недостатки.
# В Википедии есть таблица со сравнением производительности связных списков, массивов и динамических массивов.
#
# Если вопрос производительности вас не тревожит, тогда да, проще реализовать обычный список Python.
# Но научиться реализовывать собственный связный список все равно полезно.
# Это как изучение математики: у нас есть калькуляторы, но основные концепции мы все-таки изучаем.
#
# В сообществе разработчиков постоянно ведутся горячие споры о том,
# насколько целесообразно давать на технических интервью задания, связанные с алгоритмами и структурами данных.
# Возможно, в этом и нет никакого смысла, но на собеседовании вас вполне могут попросить реализовать связный список на Python.
# И теперь вы знаете, как это сделать
#https://pythonist.ru/svyaznyj-spisok-na-python-chto-eto-takoe-i-kak-ego-realizovat/